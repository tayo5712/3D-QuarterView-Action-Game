Mesh Renderer를 끄면 겉보기만 감춰짐 (collider는 그대로 남아있음)

프리펩(Prefab) : 게임오브젝트를 에셋으로 보관한 형태

Player에 필요한 컴포넌트 : Collider + Rigidbody + Script

Input 값은 Edit > Project Settings > Input Manager에서 변경 가능

GetAxisRaw() : Axis 값을 정수로 반환하는 함수
normalized : 방향 값이 1로 보정된 벡터 (대각선도 속도 같게)

transform 이동은 Time.deltaTime 곱해주기

Player가 관성에 의해 안 엎어지게 하려면 Rigidbody > Constraints > Freeze Rotation X, Z 체크

transform 이동은 물리 충돌을 무시하는 경우가 발생
-> Rigidbody > Collision Detection을 Continuous로 변경
( Static과 충돌할 때 효과적 )

애니메이터 사용시
애니메이션 상태 사이를 Transition 으로 연결
파라메터(매개변수) 추가
파라메터를 Condition에 사용하여 Transition 완성

LookAt() : 지정된 벡터를 향해서 회전시켜주는 함수
        // 우리가 나아가는 방향으로 바라본다.
        transform.LookAt(transform.position + moveVec);

코드 기능에 따라 구분되게 함수로 분리하기

키보드를 누르고 있을 때
Input.GetButton();
키보드를 누른 그 순간만
Input.GetButtonDown();

AddForce() 함수로 물리적인 힘을 가하기
OnCollisionEnter() 이벤트 함수로 착지 구현

일회성 애니메이션은 Trigger 파라메터 사용

중력 설정
Edit > Project Settings > Physics

바닥 Rigidbody 설정
Use Gravity 체크 해제
IsKinematic 체크 ( 직접 움직이지 않는 한 안 움직임 )

마찰력이 없는 벽을 만들기 위해 Physics Material 추가

Invoke() 함수로 시간차 함수 호출

RotateAround(위치, 회전축, 회전수치) : 타겟 주위를 회전하는 함수 
// 목표가 움직이면 일그러지는 단점이 있음

오브젝트 꾸미기
- Light
	Type : Point
	Range : 빛의범위
	Color : 빛의 색깔
	Intensity : 빛의 강도
- Particle System
	Renderer : Material 찾아서 연결
	(색상이 자홍색 이면 재질을 못 찾았다는 의미)
	(Default-Line 연결)
	Emission : 파티클 입자 출력양
		- Rate over Distance : 파티클의 위치 변화에 따라 입자 생성
	Shape : 파티클 입자 출력 모양
	Color Over Life Time : 시간에 따른 색상변화
	(아래쪽은 색, 위쪽은 투명도)
	Size Over Life Time : 시간에 따른 크기변화
	Limit Velocity over Life Time : 시간에 따른 속도제한
	(Drag값 조정해서 퍼지는 범위 결정)
	Start Life Time : 입자 생존 시간
	Start Speed : 입자 시작 속도

상호작용 위한 Collider는 꼭 IsTrigger 체크

OnTriggerEnter : trigger 달린 놈이랑 접촉하면
OnTriggerStay : trigger 달린 놈이랑 접촉 중이면
OnTriggerExit : 접촉에서 벗어나면

프리팹 위치는 항상 0으로 초기화

캐릭터가 물건 손에 들게 하려면
해당 위치에 Creat 3D Object한 후 물건 프리펩 끌어다 놓기

Trail Renderer : 잔상을 그려주는 컴포넌트
	Width Curve : 꼬리 모양 내도록 넓이 설정
	Time : 잔상의 길이
	Min Vertex Distance : 잔상 꺾임을 설정
	Color : 잔상 색상

코루틴 함수 : 메인루틴 + 코루틴 (동시 실행)
	StartCoroutine("") : 코루틴 실행 함수
	StartCoroutine("") : 코루틴 중단 함수
	IEnumerator : 열거형 함수 클래스
	yield : 결과를 전달하는 키워드
		- yield 키워드를 여러개 사용하여 시간차 로직 작성 가능
		- WaitForSeconds() : 주어진 수치만큼 기다리는 함수
		- yield break로 코루틴 탈출
	While문에는 꼭 yield return null을 포함

프리펩 인스턴스 생성
GameObject instant = Instantiate(프리펩, 위치, 각도);

Rigidbody 메서드
	- AddForce() : 힘 가하기
	- AddTorque() : 회전 시키기
			
마우스에 의한 캐릭터 회전 구현
            // ScreenPointToRay() : 스크린에서 월드로 Ray를 쏘는 함수
            Ray ray = followCamera.ScreenPointToRay(Input.mousePosition);
            // RaycastHit 정보를 저장할 변수 추가
            RaycastHit rayHit;
            // out : return처럼 반환값을 주어진 변수에 저장하는 키워드
            if (Physics.Raycast(ray, out rayHit, 100))
            {
                // RayCastHit의 마우스 클릭 위치 활용하여 회전을 구현
                Vector3 nextVec = rayHit.point - transform.position;
                transform.LookAt(transform.position + nextVec);
            }

상속 시 주의사항
	Awake() 함수는 자식 스크립트만 단독 실행!

Rigidbody
AngularVelocity : 물리 회전 속도

Edit > Physics > Layer Collsion Masks : 레이어들의 상호간 충돌 설정

벽 관통 방지
DrawRay(시작 위치, 쏘는 방향, 색깔) : Scene내에서 Ray를 보여주는 함수
Raycast(시작 위치, 방향, 길이, 레이어마스크) : Ray를 쏘아 닿는 오브젝트를 감지하는 함수

Material은  Mesh Renderer 컴포넌트에서 접근 가능

프리펩 생성
GameObject 변수 = Instantiate(프리펩, 위치, 각도)

구체 모양의 레이캐스팅 (모든 오브젝트)
RaycastHit[] rayHits = Physics.SphereCastAll(위치, 반지름, 쏘는 방향, 레이를 쏘는 길이, 레이어 마스크)

SetDestination() : 도착할 목표 위치 지정 함수
# A.I.
Nav 관련 클래스는 UnityEngine.AI 네임스페이스 사용 
NavMeshAgent : Navigation을 사용하는 인공지능 컴포넌트
NavAgent를 사용하기 위해선 NavMesh가 필요
NavMesh : NavAgent가 경로를 그리기 위한 바탕 (Mesh)
window > AI > Navigation
Navigation 창에서 NavMesh를 Bake로 생성
NavMesh는 Static 오브젝트만 Bake 가능
Navigation의 Agent 세팅 값으로 NavMesh 결정

# UI
UI생성 : 하이어라키 + > UI > Canvas
 - EventSystem : UI에서 키 입력을 결정해주는 컴포넌트

Panel 생성 :  UI > Panel
Image 생성 : UI > Image
	- 이미지 추가 후 스프라이트를 Image > Source Image에 드래그하여 적용
Text 생성 : UI > Legacy > Text
	- Text의 크기를 무시하고 보여주려면 OverFlow 선택
	- Text가 흐려 보일 때 : Text Scale의 값을 작게 할 수록 뚜렷한 느낌을 얻을 수 있다.
Button 생성 : UI > Legacy > Button
	- 이미지 깨져 보일 때 : Image Type(Simple) > Set Native Size > Image Type(Sliced)
Set Native Size : UI 크기를 이미지 원래 크기로 맞추는 기능

Canvas > Canvas > Pixel Perfect 체크 : sprite 도트 이미지 사용 시
Canvas > Canvas Scaler > UI Scale Mode -> Scale With Screen Size (어느 해상도에서도 크기가 동일하게 출력)
	해상도 설정 Reference Resolution - x : 1920, y : 1080

UI 생성 시 게임 오브젝트 크기는 0으로 만들기(위치만 잡아주기)
기준점 위치에 따라서 크기가 작아지는 방향이 달라짐 (앵커로 기준점 잡기)
Canvas 크기는 메인카메라 크기와 동일
인게임 : 월드 좌표계 - Transform
UI : 스크린 좌표계 - RectTransform
앵커(Anchor) : UI 중심과 위치의 방향 기준
	Shift : UI 중심
	Alt : UI 위치






